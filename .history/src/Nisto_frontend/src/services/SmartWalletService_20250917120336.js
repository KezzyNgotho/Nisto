// SmartWallet Service - Interfaces with Motoko SmartWallet backend
// Provides AI-powered auto-swapping and comprehensive swap management

class SmartWalletService {
  constructor() {
    // SmartWallet canister ID (will be set during deployment)
    this.canisterId = import.meta.env.VITE_SMART_WALLET_CANISTER_ID || 'tp4se-aiaaa-aaaau-abyha-cai';
    this.actor = null;
    this.isInitialized = false;
    
    console.log('üöÄ SmartWalletService: Initialized with canister ID:', this.canisterId);
  }

  // Initialize the SmartWallet actor (now connects to main.mo)
  async initialize() {
    if (this.isInitialized) return;
    
    try {
      // Import the main Nisto actor (generated by dfx)
      const importedModule = await import('../../../declarations/Nisto_backend/index.js');
      console.log('üîç SmartWalletService: Imported module:', importedModule);
      console.log('üîç SmartWalletService: Available exports:', Object.keys(importedModule));
      console.log('üîç SmartWalletService: canisterId:', importedModule.canisterId);
      console.log('üîç SmartWalletService: createActor:', importedModule.createActor);
      console.log('üîç SmartWalletService: Nisto_backend:', importedModule.Nisto_backend);
      console.log('üîç SmartWalletService: idlFactory:', importedModule.idlFactory);
      console.log('üîç SmartWalletService: Environment VITE_CANISTER_ID_NISTO_BACKEND:', import.meta.env.VITE_CANISTER_ID_NISTO_BACKEND);
      console.log('üîç SmartWalletService: Environment MODE:', import.meta.env.MODE);
      
      // Check if Nisto_backend exists, if not create it using createActor
      if (importedModule.Nisto_backend) {
        this.actor = importedModule.Nisto_backend;
        console.log('‚úÖ SmartWalletService: Using existing Nisto_backend actor');
      } else if (importedModule.createActor) {
        // Use the canisterId from the module or fallback to the hardcoded one
        const canisterId = importedModule.canisterId || 'tp4se-aiaaa-aaaau-abyha-cai';
        console.log('üîç SmartWalletService: Creating actor with canisterId:', canisterId);
        this.actor = importedModule.createActor(canisterId);
        console.log('‚úÖ SmartWalletService: Created new actor using createActor');
      } else {
        throw new Error('Cannot create actor: missing createActor function');
      }
      this.isInitialized = true;
      console.log('‚úÖ SmartWalletService: Connected to production main.mo contract successfully');
      console.log('üîç SmartWalletService: Actor object:', this.actor);
      
      // Debug: Check what methods are available on the actor (with null checks)
      if (this.actor && typeof this.actor === 'object') {
        console.log('üîç SmartWalletService: Actor methods available:', Object.getOwnPropertyNames(this.actor));
        console.log('üîç SmartWalletService: Actor prototype methods:', Object.getOwnPropertyNames(Object.getPrototypeOf(this.actor)));
      } else {
        throw new Error('Actor is not a valid object');
      }
      
      // Test the connection by calling a simple method
      try {
        if (this.actor.getAIUserPreferences) {
          await this.actor.getAIUserPreferences('test');
          console.log('‚úÖ SmartWalletService: Backend connection verified');
        } else {
          console.error('‚ùå SmartWalletService: getAIUserPreferences method not found on actor');
          throw new Error('getAIUserPreferences method not available');
        }
      } catch (testError) {
        console.error('‚ùå SmartWalletService: Backend connection test failed:', testError);
        throw testError; // Don't fallback, throw the error
      }
    } catch (error) {
      console.error('‚ùå SmartWalletService: Failed to initialize actor:', error);
      this.isInitialized = false;
      throw error; // Don't fallback, throw the error
    }
  }

  // Create mock actor for development/testing
  createMockActor() {
    return {
      // AI SmartWallet methods
      saveAIUserPreferences: async (userId, preferences) => {
        console.log('üîÑ Mock: saveAIUserPreferences', { userId, preferences });
        localStorage.setItem(`ai_preferences_${userId}`, JSON.stringify(preferences));
      },
      
      getAIUserPreferences: async (userId) => {
        console.log('üîÑ Mock: getAIUserPreferences', { userId });
        const stored = localStorage.getItem(`ai_preferences_${userId}`);
        if (stored) return JSON.parse(stored);
        
        // Return default preferences if none exist
        return {
          thresholdPercentage: 10,
          timeWindowMinutes: 30,
          stablecoinPreference: 'USDC',
          autoHedgingEnabled: false,
          allocationLimit: 50,
          intermediaryTokenPreference: 'USDC',
          preferredSwapProvider: 'auto'
        };
      },
      
      updateAIUserPreferences: async (userId, preferences) => {
        console.log('üîÑ Mock: updateAIUserPreferences', { userId, preferences });
        localStorage.setItem(`ai_preferences_${userId}`, JSON.stringify(preferences));
      },
      
      addAISwapRecord: async (userId, fromToken, toToken, amount, price, reason, status, errorMessage, intermediarySteps, retryCount, estimatedCompletionTime, gasCost, swapType, swapProvider) => {
        console.log('üîÑ Mock: addAISwapRecord', { userId, fromToken, toToken, amount, price, reason, status });
        const history = this.getMockSwapHistory(userId);
        const newRecord = {
          id: history.length + 1,
          userId,
          fromToken,
          toToken,
          amount,
          price,
          timestamp: Date.now(),
          reason,
          status,
          errorMessage,
          intermediarySteps,
          retryCount,
          estimatedCompletionTime,
          gasCost,
          swapType,
          swapProvider
        };
        history.push(newRecord);
        localStorage.setItem(`ai_swapHistory_${userId}`, JSON.stringify(history));
      },
      
      getAISwapHistory: async (userId) => {
        console.log('üîÑ Mock: getAISwapHistory', { userId });
        return this.getMockSwapHistory(userId);
      },
      
      analyzePortfolioAndSwap: async (userId, currentPortfolio, marketData) => {
        console.log('üîÑ Mock: analyzePortfolioAndSwap', { userId, portfolioSize: currentPortfolio.length });
        
        // Mock AI analysis
        const highRiskAssets = currentPortfolio.filter(asset => asset.change24h < -10);
        
        if (highRiskAssets.length > 0) {
          return {
            shouldSwap: true,
            reason: `High risk detected! ${highRiskAssets.map(a => a.symbol).join(', ')} dropped significantly. Consider hedging to USDC.`,
            recommendedAction: `Swap ${highRiskAssets.map(a => a.symbol).join(', ')} to USDC`,
            riskScore: 75,
            confidenceLevel: 85,
            marketConditions: 'High volatility detected',
            portfolioHealth: 'At risk - consider hedging',
            suggestedTokens: ['USDC']
          };
        }
        
        return {
          shouldSwap: false,
          reason: 'No immediate action needed. Portfolio is within acceptable risk parameters.',
          recommendedAction: 'Hold current portfolio',
          riskScore: 25,
          confidenceLevel: 60,
          marketConditions: 'Low volatility',
          portfolioHealth: 'Healthy',
          suggestedTokens: []
        };
      },
      
      getAllAIUserIds: async () => {
        console.log('üîÑ Mock: getAllAIUserIds');
        const keys = Object.keys(localStorage);
        return keys.filter(key => key.startsWith('ai_preferences_')).map(key => key.replace('ai_preferences_', ''));
      },
      
      // Legacy methods for backward compatibility
      saveUserPreferences: async (userId, preferences) => {
        return this.saveAIUserPreferences(userId, preferences);
      },
      
      getUserPreferences: async (userId) => {
        return this.getAIUserPreferences(userId);
      },
      
      addSwapRecord: async (userId, swapData) => {
        return this.addAISwapRecord(
          userId,
          swapData.fromToken,
          swapData.toToken,
          swapData.amount,
          swapData.price,
          swapData.reason,
          swapData.status,
          swapData.errorMessage,
          swapData.intermediarySteps || [],
          swapData.retryCount || 0,
          swapData.estimatedCompletionTime,
          swapData.gasCost,
          swapData.swapType || 'auto',
          swapData.swapProvider || 'auto'
        );
      },
      
      getSwapHistory: async (userId) => {
        return this.getAISwapHistory(userId);
      },
      
      updateUserPreferences: async (userId, preferences) => {
        return this.updateAIUserPreferences(userId, preferences);
      },
      
      getAllUserIds: async () => {
        return this.getAllAIUserIds();
      }
    };
  }

  // Get mock swap history for development
  getMockSwapHistory(userId) {
    const stored = localStorage.getItem(`ai_swapHistory_${userId}`);
    if (stored) return JSON.parse(stored);
    
    // Return sample data for development
    return [
      {
        id: 1,
        userId,
        fromToken: 'BTC',
        toToken: 'USDC',
        amount: 0.1,
        price: 45000,
        timestamp: Date.now() - 86400000, // 1 day ago
        reason: 'AI detected market volatility, hedging position',
        status: 'completed',
        errorMessage: null,
        intermediarySteps: ['BTC -> USDC'],
        retryCount: 0,
        estimatedCompletionTime: Date.now() - 86400000 + 300000, // 5 minutes later
        gasCost: 0.001,
        swapType: 'auto',
        swapProvider: '1INCH'
      },
      {
        id: 2,
        userId,
        fromToken: 'ETH',
        toToken: 'ICP',
        amount: 2.5,
        price: 3000,
        timestamp: Date.now() - 172800000, // 2 days ago
        reason: 'Portfolio rebalancing based on AI analysis',
        status: 'completed',
        errorMessage: null,
        intermediarySteps: ['ETH -> USDC', 'USDC -> ICP'],
        retryCount: 0,
        estimatedCompletionTime: Date.now() - 172800000 + 600000, // 10 minutes later
        gasCost: 0.002,
        swapType: 'auto',
        swapProvider: 'ICP_DEX'
      }
    ];
  }

  // User Preferences Management (AI-powered)
  async saveUserPreferences(userId, preferences) {
    await this.initialize();
    
    if (!this.actor) {
      console.error('‚ùå SmartWalletService: Actor not initialized');
      return false;
    }
    
    if (!this.actor.saveAIUserPreferences) {
      console.error('‚ùå SmartWalletService: saveAIUserPreferences method not available on actor');
      return false;
    }
    
    try {
      await this.actor.saveAIUserPreferences(userId, preferences);
      console.log('üíæ SmartWalletService: Saved user preferences successfully');
      return true;
    } catch (error) {
      console.error('‚ùå SmartWalletService: Failed to save user preferences:', error);
      return false;
    }
  }

  async getUserPreferences(userId) {
    await this.initialize();
    
    if (!this.actor) {
      console.error('‚ùå SmartWalletService: Actor not initialized');
      throw new Error('SmartWalletService actor not initialized');
    }
    
    if (!this.actor.getAIUserPreferences) {
      console.error('‚ùå SmartWalletService: getAIUserPreferences method not available on actor');
      return null;
    }
    
    try {
      const preferences = await this.actor.getAIUserPreferences(userId);
      console.log('üìã SmartWalletService: Retrieved user preferences:', preferences);
      return preferences;
    } catch (error) {
      console.error('‚ùå SmartWalletService: Failed to get user preferences:', error);
      return null;
    }
  }

  async updateUserPreferences(userId, preferences) {
    await this.initialize();
    
    if (!this.actor) {
      console.error('‚ùå SmartWalletService: Actor not initialized');
      return false;
    }
    
    if (!this.actor.updateAIUserPreferences) {
      console.error('‚ùå SmartWalletService: updateAIUserPreferences method not available on actor');
      return false;
    }
    
    try {
      await this.actor.updateAIUserPreferences(userId, preferences);
      console.log('üîÑ SmartWalletService: Updated user preferences successfully');
      return true;
    } catch (error) {
      console.error('‚ùå SmartWalletService: Failed to update user preferences:', error);
      return false;
    }
  }

  // Swap Record Management (AI-powered)
  async addSwapRecord(userId, swapData) {
    await this.initialize();
    
    if (!this.actor) {
      console.error('‚ùå SmartWalletService: Actor not initialized');
      return false;
    }
    
    if (!this.actor.addAISwapRecord) {
      console.error('‚ùå SmartWalletService: addAISwapRecord method not available on actor');
      return false;
    }
    
    try {
      await this.actor.addAISwapRecord(
        userId,
        swapData.fromToken,
        swapData.toToken,
        swapData.amount,
        swapData.price,
        swapData.reason,
        swapData.status,
        swapData.errorMessage,
        swapData.intermediarySteps || [],
        swapData.retryCount || 0,
        swapData.estimatedCompletionTime,
        swapData.gasCost,
        swapData.swapType || 'auto',
        swapData.swapProvider || 'auto'
      );
      console.log('üìù SmartWalletService: Added swap record successfully');
      return true;
    } catch (error) {
      console.error('‚ùå SmartWalletService: Failed to add swap record:', error);
      return false;
    }
  }

  async getSwapHistory(userId) {
    await this.initialize();
    
    if (!this.actor) {
      console.error('‚ùå SmartWalletService: Actor not initialized');
      throw new Error('SmartWalletService actor not initialized');
    }
    
    if (!this.actor.getAISwapHistory) {
      console.error('‚ùå SmartWalletService: getAISwapHistory method not available on actor');
      return [];
    }
    
    try {
      const history = await this.actor.getAISwapHistory(userId);
      console.log('üìä SmartWalletService: Retrieved swap history:', history);
      return history || [];
    } catch (error) {
      console.error('‚ùå SmartWalletService: Failed to get swap history:', error);
      return [];
    }
  }

  // AI Auto-Swap Logic (now uses main.mo contract)
  async analyzePortfolioAndSwap(userId, currentPortfolio, marketData) {
    console.log('ü§ñ SmartWalletService: Analyzing portfolio for auto-swap...', {
      userId,
      portfolioSize: currentPortfolio.length,
      marketDataPoints: marketData.length
    });

    try {
      await this.initialize();
      
      // Convert portfolio to the format expected by the contract
      const portfolioAssets = currentPortfolio.map(asset => ({
        symbol: asset.symbol,
        amount: asset.amount || 0,
        value: asset.value || 0,
        percentage: asset.percentage || 0,
        change24h: asset.change24h || 0,
        riskLevel: asset.riskLevel || 'medium'
      }));

      // Convert market data to the format expected by the contract
      const currencies = marketData.map(coin => ({
        id: coin.id || coin.symbol,
        symbol: coin.symbol,
        name: coin.name,
        price: coin.current_price || coin.price || 0,
        change24h: coin.change24h || 0,
        marketCap: coin.marketCap || coin.market_cap,
        volume: coin.volume || coin.total_volume,
        image: coin.image || '',
        icon: coin.icon || 'FiCircle',
        color: coin.color || '#6B7280'
      }));

      // Call the AI analysis method from main.mo contract
      if (!this.actor) {
        console.error('‚ùå SmartWalletService: Actor not initialized');
        return { shouldSwap: false, reason: 'Actor not initialized' };
      }
      
      if (!this.actor.analyzePortfolioAndSwap) {
        console.error('‚ùå SmartWalletService: analyzePortfolioAndSwap method not available on actor');
        return { shouldSwap: false, reason: 'Method not available' };
      }
      
      const analysis = await this.actor.analyzePortfolioAndSwap(userId, portfolioAssets, currencies);
      
      console.log('üß† SmartWalletService: AI analysis result:', analysis);
      
      if (analysis.shouldSwap) {
        console.log('‚úÖ SmartWalletService: AI recommends swap:', analysis);
        
        // Execute the recommended swap
        const swapResult = await this.executeAISwap(userId, analysis, currencies);
        
        // Record the swap using the contract
        await this.addSwapRecord(userId, {
          fromToken: analysis.suggestedTokens[0] || 'UNKNOWN',
          toToken: 'USDC', // Default to USDC for hedging
          amount: 0.1, // This would be calculated based on portfolio
          price: currencies.find(c => c.symbol === 'USDC')?.price || 1,
          reason: analysis.reason,
          status: swapResult.success ? 'completed' : 'failed',
          errorMessage: swapResult.error || null,
          intermediarySteps: [],
          retryCount: 0,
          estimatedCompletionTime: Date.now() + 300000,
          gasCost: 0.001,
          swapType: 'auto_hedge',
          swapProvider: 'auto'
        });

        return {
          shouldSwap: true,
          reason: analysis.reason,
          recommendedAction: analysis.recommendedAction,
          riskScore: analysis.riskScore,
          confidenceLevel: analysis.confidenceLevel,
          marketConditions: analysis.marketConditions,
          portfolioHealth: analysis.portfolioHealth,
          suggestedTokens: analysis.suggestedTokens
        };
      }

      return {
        shouldSwap: false,
        reason: analysis.reason,
        recommendedAction: analysis.recommendedAction,
        riskScore: analysis.riskScore,
        confidenceLevel: analysis.confidenceLevel,
        marketConditions: analysis.marketConditions,
        portfolioHealth: analysis.portfolioHealth,
        suggestedTokens: analysis.suggestedTokens
      };
    } catch (error) {
      console.error('‚ùå SmartWalletService: AI analysis failed:', error);
      return { shouldSwap: false, error: error.message };
    }
  }

  // AI Analysis Engine
  async performAIAnalysis(portfolio, marketData, preferences) {
    console.log('üß† SmartWalletService: Performing AI analysis...');

    // Market volatility analysis
    const volatilityAnalysis = this.analyzeMarketVolatility(marketData);
    
    // Portfolio risk assessment
    const riskAssessment = this.assessPortfolioRisk(portfolio, preferences);
    
    // Price movement prediction
    const pricePrediction = this.predictPriceMovements(marketData, portfolio);
    
    // Determine if swap is needed
    const shouldSwap = this.shouldExecuteSwap(volatilityAnalysis, riskAssessment, pricePrediction, preferences);
    
    if (shouldSwap) {
      return {
        shouldSwap: true,
        fromToken: riskAssessment.highRiskToken,
        toToken: preferences.stablecoinPreference,
        amount: riskAssessment.amountToSwap,
        price: pricePrediction.currentPrice,
        reason: `AI detected ${volatilityAnalysis.severity} market volatility. Hedging ${riskAssessment.percentage}% of ${riskAssessment.highRiskToken} position.`,
        intermediarySteps: this.calculateOptimalRoute(riskAssessment.highRiskToken, preferences.stablecoinPreference),
        estimatedTime: this.estimateSwapTime(preferences.preferredSwapProvider),
        gasCost: this.estimateGasCost(preferences.preferredSwapProvider),
        provider: preferences.preferredSwapProvider || 'auto'
      };
    }

    return { shouldSwap: false };
  }

  // Market Volatility Analysis
  analyzeMarketVolatility(marketData) {
    const recentChanges = marketData.slice(0, 10).map(coin => coin.change24h || 0);
    const avgChange = recentChanges.reduce((sum, change) => sum + Math.abs(change), 0) / recentChanges.length;
    
    let severity = 'low';
    if (avgChange > 10) severity = 'high';
    else if (avgChange > 5) severity = 'medium';
    
    return {
      severity,
      averageVolatility: avgChange,
      highVolatilityTokens: marketData.filter(coin => Math.abs(coin.change24h || 0) > 10)
    };
  }

  // Portfolio Risk Assessment
  assessPortfolioRisk(portfolio, preferences) {
    // Find highest risk token (highest volatility or largest position)
    const highRiskToken = portfolio.reduce((max, token) => {
      const risk = Math.abs(token.change24h || 0) * (token.amount || 0);
      const maxRisk = Math.abs(max.change24h || 0) * (max.amount || 0);
      return risk > maxRisk ? token : max;
    }, portfolio[0] || {});

    const percentage = Math.min(preferences.thresholdPercentage || 20, 50); // Max 50%
    const amountToSwap = (highRiskToken.amount || 0) * (percentage / 100);

    return {
      highRiskToken: highRiskToken.symbol,
      amountToSwap,
      percentage,
      riskLevel: Math.abs(highRiskToken.change24h || 0) > 10 ? 'high' : 'medium'
    };
  }

  // Price Movement Prediction
  predictPriceMovements(marketData, portfolio) {
    // Simple trend analysis (in production, this would use ML models)
    const portfolioTokens = portfolio.map(p => p.symbol);
    const relevantData = marketData.filter(coin => portfolioTokens.includes(coin.symbol));
    
    const avgPrice = relevantData.reduce((sum, coin) => sum + (coin.current_price || 0), 0) / relevantData.length;
    
    return {
      currentPrice: avgPrice,
      trend: 'stable', // Would be calculated from historical data
      confidence: 0.75
    };
  }

  // Swap Decision Logic
  shouldExecuteSwap(volatility, risk, prediction, preferences) {
    if (!preferences.autoHedgingEnabled) return false;
    
    const highVolatility = volatility.severity === 'high';
    const highRisk = risk.riskLevel === 'high';
    const significantAmount = risk.amountToSwap > 0.01; // Minimum swap amount
    
    return (highVolatility || highRisk) && significantAmount;
  }

  // Optimal Route Calculation
  calculateOptimalRoute(fromToken, toToken) {
    // Simple route calculation (in production, this would use DEX routing)
    if (fromToken === toToken) return [];
    
    // Check if direct swap is possible
    const directPairs = ['BTC-USDC', 'ETH-USDC', 'ICP-USDC', 'BTC-ETH'];
    const pair = `${fromToken}-${toToken}`;
    const reversePair = `${toToken}-${fromToken}`;
    
    if (directPairs.includes(pair) || directPairs.includes(reversePair)) {
      return [`${fromToken} -> ${toToken}`];
    }
    
    // Use USDC as intermediary
    return [`${fromToken} -> USDC`, `USDC -> ${toToken}`];
  }

  // Time and Cost Estimation
  estimateSwapTime(provider) {
    const times = {
      '1INCH': 300000, // 5 minutes
      'ICP_DEX': 60000, // 1 minute
      'auto': 180000 // 3 minutes
    };
    return times[provider] || 300000;
  }

  estimateGasCost(provider) {
    const costs = {
      '1INCH': 0.002,
      'ICP_DEX': 0.0001,
      'auto': 0.001
    };
    return costs[provider] || 0.001;
  }

  // Execute AI Swap
  async executeAISwap(userId, analysis, preferences) {
    console.log('üîÑ SmartWalletService: Executing AI swap...', analysis);
    
    try {
      // Import swap services
      const OneInchService = (await import('./OneInchService')).default;
      const ICDEXService = (await import('./ICDEXService')).default;
      
      const provider = analysis.provider || preferences.preferredSwapProvider || 'auto';
      
      let swapResult;
      
      if (provider === '1INCH' || provider === 'auto') {
        try {
          swapResult = await OneInchService.executeSwap({
            fromToken: analysis.fromToken,
            toToken: analysis.toToken,
            amount: analysis.amount,
            slippage: 1,
            userAddress: userId
          });
        } catch (error) {
          if (provider === 'auto') {
            // Fallback to ICP DEX
            swapResult = await ICDEXService.executeSwap({
              fromToken: analysis.fromToken,
              toToken: analysis.toToken,
              amount: analysis.amount,
              slippage: 1,
              userAddress: userId
            });
          } else {
            throw error;
          }
        }
      } else {
        swapResult = await ICDEXService.executeSwap({
          fromToken: analysis.fromToken,
          toToken: analysis.toToken,
          amount: analysis.amount,
          slippage: 1,
          userAddress: userId
        });
      }
      
      return {
        success: swapResult.success !== false,
        transactionHash: swapResult.transactionHash,
        actualAmount: swapResult.toAmount,
        provider: provider
      };
    } catch (error) {
      console.error('‚ùå SmartWalletService: Swap execution failed:', error);
      return {
        success: false,
        error: error.message
      };
    }
  }

  // Get all users (for admin purposes)
  async getAllUserIds() {
    await this.initialize();
    
    if (!this.actor) {
      console.error('‚ùå SmartWalletService: Actor not initialized');
      return [];
    }
    
    if (!this.actor.getAllAIUserIds) {
      console.error('‚ùå SmartWalletService: getAllAIUserIds method not available on actor');
      return [];
    }
    
    try {
      const userIds = await this.actor.getAllAIUserIds();
      console.log('üë• SmartWalletService: Retrieved user IDs:', userIds);
      return userIds || [];
    } catch (error) {
      console.error('‚ùå SmartWalletService: Failed to get user IDs:', error);
      return [];
    }
  }
}

// Export singleton instance
export default new SmartWalletService();
