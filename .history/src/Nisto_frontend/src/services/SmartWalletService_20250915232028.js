// SmartWallet Service - Interfaces with Motoko SmartWallet backend
// Provides AI-powered auto-swapping and comprehensive swap management

class SmartWalletService {
  constructor() {
    // SmartWallet canister ID (will be set during deployment)
    this.canisterId = process.env.REACT_APP_SMART_WALLET_CANISTER_ID || 'rdmx6-jaaaa-aaaah-qcaiq-cai';
    this.actor = null;
    this.isInitialized = false;
    
    console.log('🚀 SmartWalletService: Initialized with canister ID:', this.canisterId);
  }

  // Initialize the SmartWallet actor (now connects to main.mo)
  async initialize() {
    if (this.isInitialized) return;
    
    try {
      // Import the main Nisto actor (generated by dfx)
      const { Nisto } = await import('../../../declarations/Nisto_backend');
      this.actor = Nisto;
      this.isInitialized = true;
      console.log('✅ SmartWalletService: Connected to main.mo contract successfully');
    } catch (error) {
      console.error('❌ SmartWalletService: Failed to initialize actor:', error);
      // Fallback to mock implementation for development
      this.actor = this.createMockActor();
      this.isInitialized = true;
      console.log('🔄 SmartWalletService: Using mock actor for development');
    }
  }

  // Create mock actor for development/testing
  createMockActor() {
    return {
      saveUserPreferences: async (userId, preferences) => {
        console.log('🔄 Mock: saveUserPreferences', { userId, preferences });
        localStorage.setItem(`preferences_${userId}`, JSON.stringify(preferences));
      },
      
      getUserPreferences: async (userId) => {
        console.log('🔄 Mock: getUserPreferences', { userId });
        const stored = localStorage.getItem(`preferences_${userId}`);
        return stored ? JSON.parse(stored) : null;
      },
      
      addSwapRecord: async (userId, swapData) => {
        console.log('🔄 Mock: addSwapRecord', { userId, swapData });
        const history = this.getMockSwapHistory(userId);
        const newRecord = {
          id: history.length + 1,
          userId,
          ...swapData,
          timestamp: Date.now(),
          status: 'completed'
        };
        history.push(newRecord);
        localStorage.setItem(`swapHistory_${userId}`, JSON.stringify(history));
      },
      
      getSwapHistory: async (userId) => {
        console.log('🔄 Mock: getSwapHistory', { userId });
        return this.getMockSwapHistory(userId);
      },
      
      updateUserPreferences: async (userId, preferences) => {
        console.log('🔄 Mock: updateUserPreferences', { userId, preferences });
        localStorage.setItem(`preferences_${userId}`, JSON.stringify(preferences));
      },
      
      getAllUserIds: async () => {
        console.log('🔄 Mock: getAllUserIds');
        const keys = Object.keys(localStorage);
        return keys.filter(key => key.startsWith('preferences_')).map(key => key.replace('preferences_', ''));
      }
    };
  }

  // Get mock swap history for development
  getMockSwapHistory(userId) {
    const stored = localStorage.getItem(`swapHistory_${userId}`);
    if (stored) return JSON.parse(stored);
    
    // Return sample data for development
    return [
      {
        id: 1,
        userId,
        fromToken: 'BTC',
        toToken: 'USDC',
        amount: 0.1,
        price: 45000,
        timestamp: Date.now() - 86400000, // 1 day ago
        reason: 'AI detected market volatility, hedging position',
        status: 'completed',
        errorMessage: null,
        intermediarySteps: ['BTC -> USDC'],
        retryCount: 0,
        estimatedCompletionTime: Date.now() - 86400000 + 300000, // 5 minutes later
        gasCost: 0.001,
        swapType: 'auto',
        swapProvider: '1INCH'
      },
      {
        id: 2,
        userId,
        fromToken: 'ETH',
        toToken: 'ICP',
        amount: 2.5,
        price: 3000,
        timestamp: Date.now() - 172800000, // 2 days ago
        reason: 'Portfolio rebalancing based on AI analysis',
        status: 'completed',
        errorMessage: null,
        intermediarySteps: ['ETH -> USDC', 'USDC -> ICP'],
        retryCount: 0,
        estimatedCompletionTime: Date.now() - 172800000 + 600000, // 10 minutes later
        gasCost: 0.002,
        swapType: 'auto',
        swapProvider: 'ICP_DEX'
      }
    ];
  }

  // User Preferences Management (AI-powered)
  async saveUserPreferences(userId, preferences) {
    await this.initialize();
    return await this.actor.saveAIUserPreferences(userId, preferences);
  }

  async getUserPreferences(userId) {
    await this.initialize();
    return await this.actor.getAIUserPreferences(userId);
  }

  async updateUserPreferences(userId, preferences) {
    await this.initialize();
    return await this.actor.updateAIUserPreferences(userId, preferences);
  }

  // Swap Record Management (AI-powered)
  async addSwapRecord(userId, swapData) {
    await this.initialize();
    return await this.actor.addAISwapRecord(
      userId,
      swapData.fromToken,
      swapData.toToken,
      swapData.amount,
      swapData.price,
      swapData.reason,
      swapData.status,
      swapData.errorMessage,
      swapData.intermediarySteps || [],
      swapData.retryCount || 0,
      swapData.estimatedCompletionTime,
      swapData.gasCost,
      swapData.swapType || 'auto',
      swapData.swapProvider || 'auto'
    );
  }

  async getSwapHistory(userId) {
    await this.initialize();
    return await this.actor.getAISwapHistory(userId);
  }

  // AI Auto-Swap Logic
  async analyzePortfolioAndSwap(userId, currentPortfolio, marketData) {
    console.log('🤖 SmartWalletService: Analyzing portfolio for auto-swap...', {
      userId,
      portfolioSize: currentPortfolio.length,
      marketDataPoints: marketData.length
    });

    try {
      // Get user preferences
      const preferences = await this.getUserPreferences(userId);
      if (!preferences || !preferences.autoHedgingEnabled) {
        console.log('⚠️ SmartWalletService: Auto-hedging disabled for user');
        return { shouldSwap: false, reason: 'Auto-hedging disabled' };
      }

      // AI Analysis Logic
      const analysis = await this.performAIAnalysis(currentPortfolio, marketData, preferences);
      
      if (analysis.shouldSwap) {
        console.log('✅ SmartWalletService: AI recommends swap:', analysis);
        
        // Execute the recommended swap
        const swapResult = await this.executeAISwap(userId, analysis, preferences);
        
        // Record the swap
        await this.addSwapRecord(userId, {
          fromToken: analysis.fromToken,
          toToken: analysis.toToken,
          amount: analysis.amount,
          price: analysis.price,
          reason: analysis.reason,
          status: swapResult.success ? 'completed' : 'failed',
          errorMessage: swapResult.error || null,
          intermediarySteps: analysis.intermediarySteps || [],
          retryCount: 0,
          estimatedCompletionTime: Date.now() + (analysis.estimatedTime || 300000),
          gasCost: analysis.gasCost || 0.001,
          swapType: 'auto',
          swapProvider: analysis.provider || 'auto'
        });

        return swapResult;
      }

      return { shouldSwap: false, reason: 'No swap needed based on AI analysis' };
    } catch (error) {
      console.error('❌ SmartWalletService: AI analysis failed:', error);
      return { shouldSwap: false, error: error.message };
    }
  }

  // AI Analysis Engine
  async performAIAnalysis(portfolio, marketData, preferences) {
    console.log('🧠 SmartWalletService: Performing AI analysis...');

    // Market volatility analysis
    const volatilityAnalysis = this.analyzeMarketVolatility(marketData);
    
    // Portfolio risk assessment
    const riskAssessment = this.assessPortfolioRisk(portfolio, preferences);
    
    // Price movement prediction
    const pricePrediction = this.predictPriceMovements(marketData, portfolio);
    
    // Determine if swap is needed
    const shouldSwap = this.shouldExecuteSwap(volatilityAnalysis, riskAssessment, pricePrediction, preferences);
    
    if (shouldSwap) {
      return {
        shouldSwap: true,
        fromToken: riskAssessment.highRiskToken,
        toToken: preferences.stablecoinPreference,
        amount: riskAssessment.amountToSwap,
        price: pricePrediction.currentPrice,
        reason: `AI detected ${volatilityAnalysis.severity} market volatility. Hedging ${riskAssessment.percentage}% of ${riskAssessment.highRiskToken} position.`,
        intermediarySteps: this.calculateOptimalRoute(riskAssessment.highRiskToken, preferences.stablecoinPreference),
        estimatedTime: this.estimateSwapTime(preferences.preferredSwapProvider),
        gasCost: this.estimateGasCost(preferences.preferredSwapProvider),
        provider: preferences.preferredSwapProvider || 'auto'
      };
    }

    return { shouldSwap: false };
  }

  // Market Volatility Analysis
  analyzeMarketVolatility(marketData) {
    const recentChanges = marketData.slice(0, 10).map(coin => coin.change24h || 0);
    const avgChange = recentChanges.reduce((sum, change) => sum + Math.abs(change), 0) / recentChanges.length;
    
    let severity = 'low';
    if (avgChange > 10) severity = 'high';
    else if (avgChange > 5) severity = 'medium';
    
    return {
      severity,
      averageVolatility: avgChange,
      highVolatilityTokens: marketData.filter(coin => Math.abs(coin.change24h || 0) > 10)
    };
  }

  // Portfolio Risk Assessment
  assessPortfolioRisk(portfolio, preferences) {
    // Find highest risk token (highest volatility or largest position)
    const highRiskToken = portfolio.reduce((max, token) => {
      const risk = Math.abs(token.change24h || 0) * (token.amount || 0);
      const maxRisk = Math.abs(max.change24h || 0) * (max.amount || 0);
      return risk > maxRisk ? token : max;
    }, portfolio[0] || {});

    const percentage = Math.min(preferences.thresholdPercentage || 20, 50); // Max 50%
    const amountToSwap = (highRiskToken.amount || 0) * (percentage / 100);

    return {
      highRiskToken: highRiskToken.symbol,
      amountToSwap,
      percentage,
      riskLevel: Math.abs(highRiskToken.change24h || 0) > 10 ? 'high' : 'medium'
    };
  }

  // Price Movement Prediction
  predictPriceMovements(marketData, portfolio) {
    // Simple trend analysis (in production, this would use ML models)
    const portfolioTokens = portfolio.map(p => p.symbol);
    const relevantData = marketData.filter(coin => portfolioTokens.includes(coin.symbol));
    
    const avgPrice = relevantData.reduce((sum, coin) => sum + (coin.current_price || 0), 0) / relevantData.length;
    
    return {
      currentPrice: avgPrice,
      trend: 'stable', // Would be calculated from historical data
      confidence: 0.75
    };
  }

  // Swap Decision Logic
  shouldExecuteSwap(volatility, risk, prediction, preferences) {
    if (!preferences.autoHedgingEnabled) return false;
    
    const highVolatility = volatility.severity === 'high';
    const highRisk = risk.riskLevel === 'high';
    const significantAmount = risk.amountToSwap > 0.01; // Minimum swap amount
    
    return (highVolatility || highRisk) && significantAmount;
  }

  // Optimal Route Calculation
  calculateOptimalRoute(fromToken, toToken) {
    // Simple route calculation (in production, this would use DEX routing)
    if (fromToken === toToken) return [];
    
    // Check if direct swap is possible
    const directPairs = ['BTC-USDC', 'ETH-USDC', 'ICP-USDC', 'BTC-ETH'];
    const pair = `${fromToken}-${toToken}`;
    const reversePair = `${toToken}-${fromToken}`;
    
    if (directPairs.includes(pair) || directPairs.includes(reversePair)) {
      return [`${fromToken} -> ${toToken}`];
    }
    
    // Use USDC as intermediary
    return [`${fromToken} -> USDC`, `USDC -> ${toToken}`];
  }

  // Time and Cost Estimation
  estimateSwapTime(provider) {
    const times = {
      '1INCH': 300000, // 5 minutes
      'ICP_DEX': 60000, // 1 minute
      'auto': 180000 // 3 minutes
    };
    return times[provider] || 300000;
  }

  estimateGasCost(provider) {
    const costs = {
      '1INCH': 0.002,
      'ICP_DEX': 0.0001,
      'auto': 0.001
    };
    return costs[provider] || 0.001;
  }

  // Execute AI Swap
  async executeAISwap(userId, analysis, preferences) {
    console.log('🔄 SmartWalletService: Executing AI swap...', analysis);
    
    try {
      // Import swap services
      const OneInchService = (await import('./OneInchService')).default;
      const ICDEXService = (await import('./ICDEXService')).default;
      
      const provider = analysis.provider || preferences.preferredSwapProvider || 'auto';
      
      let swapResult;
      
      if (provider === '1INCH' || provider === 'auto') {
        try {
          swapResult = await OneInchService.executeSwap({
            fromToken: analysis.fromToken,
            toToken: analysis.toToken,
            amount: analysis.amount,
            slippage: 1,
            userAddress: userId
          });
        } catch (error) {
          if (provider === 'auto') {
            // Fallback to ICP DEX
            swapResult = await ICDEXService.executeSwap({
              fromToken: analysis.fromToken,
              toToken: analysis.toToken,
              amount: analysis.amount,
              slippage: 1,
              userAddress: userId
            });
          } else {
            throw error;
          }
        }
      } else {
        swapResult = await ICDEXService.executeSwap({
          fromToken: analysis.fromToken,
          toToken: analysis.toToken,
          amount: analysis.amount,
          slippage: 1,
          userAddress: userId
        });
      }
      
      return {
        success: swapResult.success !== false,
        transactionHash: swapResult.transactionHash,
        actualAmount: swapResult.toAmount,
        provider: provider
      };
    } catch (error) {
      console.error('❌ SmartWalletService: Swap execution failed:', error);
      return {
        success: false,
        error: error.message
      };
    }
  }

  // Get all users (for admin purposes)
  async getAllUserIds() {
    await this.initialize();
    return await this.actor.getAllUserIds();
  }
}

// Export singleton instance
export default new SmartWalletService();
